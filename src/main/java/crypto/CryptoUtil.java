package crypto;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Arrays;

public class CryptoUtil {

    // The length of the initialization vector
    public static final int IV_LENGTH = 16;
    // Used for creating byte arrays from Strings/char[] and vice versa
    public static final Charset ENCODER = StandardCharsets.UTF_8;
    // The algorithm used during encryption
    //private static final String ALGORITHM_MODE_PADDING = "AES/GCM/NoPadding";
    public static final String ALGORITHM_MODE_PADDING = "AES/CBC/PKCS5PADDING";
    public static final String ALGORITHM = "AES";

    // The length of the salt, in bytes, generated for SCrypt during key generation. Ensures encryption output
    // differs each time encryption occurs
    public static final int SALT_LENGTH = 32;
    // The number of iterations for SCrypt to make when creating a key; a power of 2; bigger numbers = more time
    public static final int SCRYPT_ITERATIONS_COUNT = 262144;
    public static final int SCRYPT_ITERATIONS_COUNT_AUTHORIZATION = 16384;
    // The block size used by SCrypt during key generation. Bigger = more memory required
    public static final int SCRYPT_BLOCK_SIZE = 8;
    // The number of threads used by SCrypt; bigger = more threads, = more memory
    public static final int SCRYPT_PARALLELISM_FACTOR = 1;
    // The length of the key generated by SCrypt and used by AES; must be 128, 192 or 256 bits
    public static final int SCRYPT_KEY_LENGTH_BITS = 256;
    public static final int SCRYPT_KEY_LENGTH = SCRYPT_KEY_LENGTH_BITS / 8;

    public static String AUTHENTICATION_ALGORITHM = "HmacSHA256";
    // The length of the output of the authentication algorithm
    public static final int AUTHENTICATION_DATA_LENGTH_BITS = 256;
    public static final int AUTHENTICATION_DATA_LENGTH = AUTHENTICATION_DATA_LENGTH_BITS / 8;



    /**
     * Writes over a byte array with zeroes. If data references null, the method does nothing
     * @param data An array of bytes to overwrite
     */
    public static void erase(byte[] data) {
        if(data == null)
            return;
        Arrays.fill(data, (byte)0);
    }

    /**
     * Writes over a char array with zeroes. If data references null, the method does nothing
     * @param data An array of chars to overwrite
     */
    public static void erase(char[] data) {
        if(data == null)
            return;
        Arrays.fill(data, (char)0);
    }

    /**
     * Creates a new array with a given size and fills it with random values
     * @param size The size of the new array
     * @return a byte array of randomly generated values with the desired size
     */
    public static byte[] randomBytes(int size) {
        byte[] bytes = new byte[size];
        SecureRandom prng = new SecureRandom();
        prng.nextBytes(bytes);
        return bytes;
    }

    /**
     * Generates an array of random bytes to be used for password salting, with length set by
     * {@link PasswordBasedCryptographer @SALT_LENGTH}
     * @return an array of random bytes with the predefined size
     */
    public static byte[] generateSalt() {
        return randomBytes(SALT_LENGTH);
    }

    /**
     * Generates an array of random bytes to be used for initialization vectors, with length set by
     * {@link PasswordBasedCryptographer#IV_LENGTH}
     * @return an array of random bytes with the predefined size
     */
    public static byte[] generateIV() {
        return randomBytes(IV_LENGTH);
    }
}
